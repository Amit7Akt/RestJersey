<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><title>JBoss Tools Aggregated Feed</title><link rel="alternate" href="http://tools.jboss.org" /><subtitle>JBoss Tools Aggregated Feed</subtitle><dc:creator>JBoss Tools</dc:creator><entry><title>How to autoscale your SaaS application infrastructure</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/01/12/how-autoscale-saas-application-infrastructure" /><author><name>Michael Hrivnak</name></author><id>3f2c7cc6-3830-4b59-978c-bb0d62a5ca5f</id><updated>2023-01-12T07:00:00Z</updated><published>2023-01-12T07:00:00Z</published><summary type="html">&lt;p&gt;This article discusses both how and why to scale your infrastructure automatically so that you aren't paying for resources you don't need. This is the last installment in the &lt;a href="https://developers.redhat.com/articles/2022/05/18/saas-architecture-checklist-kubernetes"&gt;SaaS architecture checklist series&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;If you are a Software-as-a-Service (SaaS) provider, it is important to manage operational expenses while ensuring that your platform's capacity can always meet the needs of your users. Whether the traffic to your SaaS peaks on a predictable schedule (for example, office hours on weekdays or seasonal shopping) or whether you are planning for growth, &lt;a href="https://developers.redhat.com/topics/kubernetes"&gt;Kubernetes&lt;/a&gt; has features to make sure you have the right level of capacity at any given time.&lt;/p&gt; &lt;p&gt;SaaS revenue typically comes through recurring fees that scale based on metrics such as the number of users, quantity of data stored or processed, access to advanced features, and other similar points of value. While each SaaS provider decides on their own pricing model and consumption metric, there is one common goal: The more your SaaS gets used, the more revenue you make.&lt;/p&gt; &lt;p&gt;But that usage also incurs increased infrastructure demand and expense. Maintaining a healthy operating income depends on keeping your infrastructure expenses below the corresponding revenue.&lt;/p&gt; &lt;p&gt;It pays to build on a compute platform that can scale in response to demand, with automation that scales the application in real-time. This article will discuss basic techniques for automatically scaling a Kubernetes cluster and an application based on load by combining three components:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Cluster API to enable cluster resizing&lt;/li&gt; &lt;li&gt;Cluster Autoscaler to resize the cluster based on load&lt;/li&gt; &lt;li&gt;Horizontal Pod Autoscaler to scale an application based on load&lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;Kubernetes native infrastructure&lt;/h2&gt; &lt;p&gt;Kubernetes native infrastructure is a pattern for using the Kubernetes API to manage some or all of the compute and network infrastructure used by a cluster. This concept is the foundation for some of the scalability components described in the following sections.&lt;/p&gt; &lt;p&gt;You can extend the Kubernetes API through &lt;a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/"&gt;custom resources&lt;/a&gt;, which allow a software developer to add a new API endpoint to a cluster, write a controller to implement the features of that endpoint, and thus create a Kubernetes-native API to manage almost anything. You might have heard of the &lt;a href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/"&gt;Operator Pattern&lt;/a&gt; that uses this technique of extending the Kubernetes API, typically for the purpose of managing applications, but custom resources can also be used to manage infrastructure.&lt;/p&gt; &lt;h2&gt;Cluster API&lt;/h2&gt; &lt;p&gt;The &lt;a href="https://cluster-api.sigs.k8s.io/"&gt;Cluster API project&lt;/a&gt; is a popular example of Kubernetes-native infrastructure management. One of its core capabilities is to add and remove nodes in an existing cluster using a concept called Machines. The API has a Machine API resource, which represents the desire to have a node in a cluster. The API also has a MachineSet API resource (similar in concept to a ReplicaSet), which includes a desired size and a template for creating Machines.&lt;/p&gt; &lt;p&gt;The Machine and MachineSet APIs let you resize a cluster just by changing an integer field to the number of nodes you desire. Figure 1 shows the API's basic behavior.&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/Openshift%20cluster%20image.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/Openshift%20cluster%20image.png?itok=iqBIj8Bd" width="461" height="512" alt="The Machine API watches for changes and implements them using the platform-specific API." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 1: The Machine API watches for changes and implements them using the platform-specific API.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt;At a very high level, cluster scaling using the cluster API project works like this:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;A person or automation decides to change the size of a MachineSet (more on this later).&lt;/li&gt; &lt;li&gt;A controller process either creates new Machine resources or deletes existing ones based on comparing the desired number of machines to the number that actually exists.&lt;/li&gt; &lt;li&gt;When a new Machine resource gets created, a platform-specific controller uses a cloud API to add a host to the cluster. For example, on AWS the controller would use the EC2 API to provision a new host.&lt;/li&gt; &lt;li&gt;When a Machine resource gets deleted, the platform-specific controller drains the corresponding node of workloads and then uses the platform-specific API to delete the host.&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;With this simple approach, it's easy to scale a cluster up and down. The API works the same across different cloud providers, so scaling changes can be made without any cloud-specific knowledge.&lt;/p&gt; &lt;p&gt;But how can the scaling decision to add and remove nodes be automated based on the real-time load? That's the responsibility of the Cluster Autoscaler.&lt;/p&gt; &lt;h2&gt;Cluster Autoscaler&lt;/h2&gt; &lt;p&gt;The &lt;a href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler#cluster-autoscaler"&gt;Cluster Autoscaler&lt;/a&gt; uses the Machine API to add and remove nodes in a cluster based on its observations of workload scheduling pressure and node utilization. The Autoscaler adds nodes when pods cannot be scheduled due to resource constraints and removes underused nodes. Additional configuration is available, such as limits on how many nodes to create and settings that tune how aggressively the Autoscaler removes underused nodes.&lt;/p&gt; &lt;p&gt;Combining the Machine API with the Cluster Autoscaler, you can have a self-scaling compute platform that responds to the resource needs of your SaaS application.&lt;/p&gt; &lt;p&gt;To learn more about how &lt;a href="https://developers.redhat.com/openshift"&gt;Red Hat OpenShift&lt;/a&gt; enables machine management and scaling, including example resources, see the &lt;a href="https://docs.openshift.com/container-platform/4.11/machine_management/index.html"&gt;overview of machine management&lt;/a&gt; and the &lt;a href="https://docs.openshift.com/container-platform/4.11/machine_management/applying-autoscaling.html"&gt;autoscaler section&lt;/a&gt; of the product documentation.&lt;/p&gt; &lt;p&gt;But there is one more piece to the puzzle: How can you scale your application, adding and removing pods as its load changes over time? That is the job of the Horizontal Pod Autoscaler.&lt;/p&gt; &lt;h2&gt;Horizontal Pod Autoscaler&lt;/h2&gt; &lt;p&gt;&lt;a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/"&gt;Horizontal Pod Autoscaling&lt;/a&gt; adds and removes pods in response to changing load. The service bases decisions on two metrics: CPU utilization and memory footprint. You can define thresholds at which pods will be added or removed to keep per-pod resource utilization near target values. In a common use case where a workload is defined as a &lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/"&gt;Deployment&lt;/a&gt;, this Autoscaler adjusts the &lt;strong&gt;replicas&lt;/strong&gt; field based on load.&lt;/p&gt; &lt;p&gt;In the following example, a &lt;code&gt;frontend-app&lt;/code&gt; Deployment resource varies from 10 to 100 pods. Crucially, the Deployment's pod template must include a CPU &lt;a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits"&gt;resource request&lt;/a&gt;. The Autoscaler uses each pod's actual CPU utilization to calculate a percentage of its CPU request and then uses the average to determine whether to scale the application up or down.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-yaml"&gt; apiVersion: autoscaling/v1 kind: HorizontalPodAutoscaler metadata: name: frontend-app namespace: default spec: maxReplicas: 100 minReplicas: 10 scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: frontend-app targetCPUUtilizationPercentage: 75&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The newer &lt;a href="https://github.com/kubernetes/design-proposals-archive/blob/main/autoscaling/hpa-v2.md"&gt;autoscaling/v2 API&lt;/a&gt; lets you scale based on memory utilization and define more sophisticated policies. New policy options can configure how rapidly to make changes, including different policies that apply to scaling up versus scaling down. This API also supports the use of custom metrics.&lt;/p&gt; &lt;h2&gt;SaaS provisioning can be automated under Kubernetes&lt;/h2&gt; &lt;p&gt;Combining the Cluster API, Cluster Autoscaler, and Horizontal Pod Autoscaler, you can automatically scale your SaaS application up and down based on changes in utilization. The underlying infrastructure will automatically scale with your resource specifications, saving costs when utilization is low.&lt;/p&gt; &lt;p&gt;Red Hat SaaS Foundations is a partner program designed for building enterprise-grade SaaS solutions on the &lt;a href="https://developers.redhat.com/products/openshift/"&gt;Red Hat OpenShift&lt;/a&gt; or &lt;a href="https://developers.redhat.com/products/rhel/overview"&gt;Red Hat Enterprise Linux&lt;/a&gt; platforms and deploying them across multiple cloud and non-cloud footprints. &lt;a href="http://mailto:saas@redhat.com"&gt;Email&lt;/a&gt; us to learn more about partnering with Red Hat to build your SaaS.&lt;/p&gt; &lt;p&gt;Be sure to read all the articles in the &lt;a href="https://developers.redhat.com/articles/2022/05/18/saas-architecture-checklist-kubernetes"&gt;SaaS architecture checklist series&lt;/a&gt;. Comment below if you have questions. We welcome your feedback. &lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/01/12/how-autoscale-saas-application-infrastructure" title="How to autoscale your SaaS application infrastructure"&gt;How to autoscale your SaaS application infrastructure&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Michael Hrivnak</dc:creator><dc:date>2023-01-12T07:00:00Z</dc:date></entry><entry><title type="html">JUnit 5 Cheatsheet (2023)</title><link rel="alternate" href="http://www.mastertheboss.com/various-stuff/testing-java/junit-5-cheatsheet/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/various-stuff/testing-java/junit-5-cheatsheet/</id><updated>2023-01-11T16:51:23Z</updated><content type="html">This article contains a JUnit 5 Cheatsheet which you can use as handy reference to build your JUnit 5 Jupiter Tests in Java. Maven Dependencies: Here is the list of dependencies you have to include in your pom.xml according to the latest JUnit version (): &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title type="html">JUnit 5 Made Easy</title><link rel="alternate" href="http://www.mastertheboss.com/various-stuff/testing-java/getting-started-with-junit/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/various-stuff/testing-java/getting-started-with-junit/</id><updated>2023-01-11T16:09:45Z</updated><content type="html">JUnit 5 is a powerful testing framework for Java developers, allowing you to write and run repeatable, automated tests for your code. With its clear and expressive syntax, JUnit 5 makes it easy to write tests for a wide range of scenarios and use cases, from simple unit tests to complex integration tests. In this ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title type="html">Modern Java interview questions (2023)</title><link rel="alternate" href="http://www.mastertheboss.com/java/modern-java-interview-questions/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/java/modern-java-interview-questions/</id><updated>2023-01-11T09:25:33Z</updated><content type="html">Are you going for a Java Interview ? This article contains a list of Interview Questions which are covering modern aspects of Java, such as Functional programming, Stream API, new IO API and much more. Java Records What is a Java Record and how it compares with a Java Class? A record is a concise ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title>A developer's guide to using OpenShift with Kubernetes</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/01/11/developers-guide-using-openshift-kubernetes" /><author><name>Bob Reselman</name></author><id>aa8727f0-0250-4f91-a8fb-e9c3270724bc</id><updated>2023-01-11T07:00:00Z</updated><published>2023-01-11T07:00:00Z</published><summary type="html">&lt;p&gt;This article is the second in a series that describes the relationship between &lt;a href="https://developers.redhat.com/topics/kubernetes"&gt;Kubernetes&lt;/a&gt; and &lt;a href="https://developers.redhat.com/openshift"&gt;Red Hat OpenShift&lt;/a&gt;. The first article, &lt;em&gt;An OpenShift Developers Guide to the Essentials of Kubernetes&lt;/em&gt;, described basic Kubernetes concepts, components, and resources. This installment describes what OpenShift is and what it does. I'll also describe the relationship between Kubernetes and OpenShift, and briefly explain some of the basics for working with OpenShift and Kubernetes using both the web console and OpenShift's &lt;code&gt;oc&lt;/code&gt; command-line interface (CLI).&lt;/p&gt; &lt;h2&gt;OpenShift simplifies Kubernetes&lt;/h2&gt; &lt;p&gt;Kubernetes is popular and powerful, but it's not easy to use. You have to know a lot even to do a simple task. The learning curve can be daunting. OpenShift makes working with Kubernetes a lot easier by providing a layer of abstraction over Kubernetes that removes a good deal of Kubernetes's operational complexity from the day-to-day developer experience. Figure 1 shows the place of OpenShift in the software stack.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/figure-01_0.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/figure-01_0.png?itok=BpImsHv4" width="391" height="151" alt="Shows the place of OpenShift in the software stack." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 1: OpenShift runs on top of Kubernetes, Linux containers, and Red Hat Enterprise Linux.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt; &lt;/p&gt; &lt;p&gt;One button click in the OpenShift web console can do the work on a Kubernetes cluster that otherwise would require fiddling with a configuration file or typing half a dozen commands into a terminal window. In addition to providing a graphical user interface (UI) that makes it easier to work with Kubernetes, OpenShift has a set of features that enhance application deployment and maintenance. For example, OpenShift allows you to deploy an application from source code in a remote repository directly into the underlying Kubernetes cluster.&lt;/p&gt; &lt;p&gt;Also, OpenShift enables application deployment from existing container images that are stored in a container image repository. These two features alone save hours of work for developers and release personnel (who would also need to be part of the deployment process). Again, OpenShift does not replace Kubernetes. Rather, it improves and enhances the experience for those who work with Kubernetes.&lt;/p&gt; &lt;p&gt;The trick to working with OpenShift is to take an application-first approach. This means using OpenShift to select the type of application you want, either by starting from scratch or by using pre-existing code. The pre-existing code can be a container image or source code in a remote source code repository. After you select an application type, OpenShift does the work of setting it up in the underlying Kubernetes cluster. You don't have to fiddle around with configuration files or create Kubernetes resources manually. OpenShift does all that work, thus enabling you to focus on the higher-level concerns of application design.&lt;/p&gt; &lt;h2&gt;Understanding OpenShift projects and Kubernetes namespaces&lt;/h2&gt; &lt;p&gt;In OpenShift, the project is the organizational unit for applications. A project is OpenShift's way of organizing all the underlying Kubernetes resources that make up a web application into a single formal, operational entity. Under Kubernetes, you create a web application by composing all the underlying Kubernetes resources that make up the application. In contrast, under OpenShift you start by declaring the project and then let OpenShift do the work of creating and organizing the Kubernetes resources required to support the application. It is a subtle difference but an important one. We will discuss the application-first approach later in this article.&lt;/p&gt; &lt;p&gt;An OpenShift project is the same as a Kubernetes &lt;a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/"&gt;namespace&lt;/a&gt;. When you create a project in OpenShift, you are also creating a Kubernetes namespace under the covers. That Kubernetes namespace has the same name as the OpenShift project. All the underlying Kubernetes resources that support the OpenShift application are assigned to the Kubernetes namespace that correlates to the OpenShift project under which the application is running.&lt;/p&gt; &lt;h2&gt;How to work with oc and kubectl CLI tools&lt;/h2&gt; &lt;p&gt;There are two ways for developers to work with OpenShift. One way is using the graphical web console. The other way is to use &lt;code&gt;oc&lt;/code&gt; at the command line.&lt;/p&gt; &lt;p&gt;The &lt;code&gt;oc&lt;/code&gt; CLI provides all the capabilities available in &lt;code&gt;kubectl&lt;/code&gt;, which is the native to Kubernetes. However, &lt;code&gt;oc&lt;/code&gt; goes beyond the capabilities of &lt;code&gt;kubectl&lt;/code&gt; and allows developers to work with features that are special to OpenShift.&lt;/p&gt; &lt;p&gt;There are also two ways to use &lt;code&gt;oc&lt;/code&gt;. The first way is to &lt;a href="https://docs.openshift.com/container-platform/4.7/cli_reference/openshift_cli/getting-started-cli.html"&gt;install oc on your local machine&lt;/a&gt; and use it to log in to a remote OpenShift instance. Then, once logged in, you invoke &lt;code&gt;oc&lt;/code&gt; to execute commands from a terminal window in your local machine (Figure 2).&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/figure-02_0.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/figure-02_0.png?itok=tF2yM85l" width="600" height="193" alt="The developer is working within a terminal window, executing oc commands there." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 2: The developer is working within a terminal window, executing oc commands there.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt; &lt;/p&gt; &lt;p&gt;The second way to use &lt;code&gt;oc&lt;/code&gt; within the web console's terminal window (Figure 3).&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/figure-03_2.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/figure-03_2.png?itok=TTPLK9K3" width="600" height="394" alt="The OpenShift web console offers a terminal where you can issue commands related to your clusters." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 3: The OpenShift web console offers a terminal where you can issue commands related to your clusters.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt; &lt;/p&gt; &lt;p&gt;Anything you can do with the &lt;code&gt;kubectl&lt;/code&gt; CLI, you can also do with &lt;code&gt;oc&lt;/code&gt;. For example, the two terminals in Figure 4 use &lt;code&gt;kubectl&lt;/code&gt; and &lt;code&gt;oc&lt;/code&gt; to get a list of Kubernetes pods hosted in an OpenShift cluster.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/figure-04_0.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/figure-04_0.png?itok=PTQeUxL-" width="600" height="276" alt="Two terminals showing the output of oc and kubectl commands." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 4: The oc command offers all the operations that kubectl offers.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt; &lt;/p&gt; &lt;p&gt;In Figure 4, both &lt;code&gt;kubectl&lt;/code&gt; and &lt;code&gt;oc&lt;/code&gt; execute the &lt;code&gt;get pods&lt;/code&gt; subcommand. Because &lt;code&gt;oc&lt;/code&gt; mimics &lt;code&gt;kubectl&lt;/code&gt;, the output for each command is identical.&lt;/p&gt; &lt;h2&gt;How to use the web console&lt;/h2&gt; &lt;p&gt;In addition to using the &lt;code&gt;oc&lt;/code&gt; CLI to interact with OpenShift, developers can use the web console. This graphical interface allows developers to work with OpenShift projects, applications, and an application's constituent components. This section provides a basic overview of the console, which you log into through your browser.&lt;/p&gt; &lt;p&gt;You can use the web console to add projects and applications to an OpenShift cluster. You can also manage the various Kubernetes and OpenShift resources in the cluster through the console. You can use the web console to observe application behavior, configure security settings, and set access credentials. These are just a few of the many capabilities available.&lt;/p&gt; &lt;p&gt;The web console UI has two presentation perspectives: administrator and developer (Figure 5). As the names imply, the administrator perspective performs administrative tasks in the web console, such as configuring networks, configuring users, and creating persistent volume claims. The developer perspective is where you can create and maintain applications, as well as observe application behavior. However, there are tasks in either administrator or developer perspective, such as creating &lt;a href="https://kubernetes.io/docs/concepts/configuration/secret/"&gt;secrets&lt;/a&gt;.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/figure-05.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/figure-05.png?itok=ZYMa7M7v" width="279" height="220" alt="The web console displays the administrator and developer options." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 5: When you start using the web console, choose the administrator or developer perspective.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Figure 6 shows screenshots of both the Developer and Administrator perspectives in the web console.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/figure-06_1.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/figure-06_1.png?itok=ZJMI6mzw" width="600" height="288" alt="Different resources are displayed by the Developer and Administrator perspectives in the console." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 6: Different resources are displayed by the Developer and Administrator perspectives in the console.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt; &lt;/p&gt; &lt;p&gt;Each perspective provides a number of capabilities in the vertical menu bar on the left side of the console's web page. Clicking on an item in the menu bar presents a web page that has the details of the selected menu item. Be advised that most of the web pages you'll be presented with require some understanding of various Kubernetes resources, so you need a basic understanding of Kubernetes. This makes sense. After all, one of the key benefits of OpenShift is that it enhances one's ability to work with Kubernetes.&lt;/p&gt; &lt;p&gt;The web console does take time to master. But it's not an all-or-nothing undertaking. You can learn what you need to know in small increments, according to the task you want to complete.&lt;/p&gt; &lt;h2&gt;How to run an application in OpenShift&lt;/h2&gt; &lt;p&gt;Now that you have a very high-level overview of the OpenShift web console, let's use the console to install and run an application in OpenShift. As mentioned previously, OpenShift is an operational layer that sits on top of a Kubernetes cluster. Developers use the OpenShift web console to deploy applications. In turn, OpenShift frees developers from the tedium that goes with creating the various Kubernetes resources that make up the given application.&lt;/p&gt; &lt;p&gt;However, even though you don't have to do the work of creating Kubernetes resources, at some point you might need to interact with them. Fortunately, OpenShift Web Console exposes all of an application's Kubernetes resources. You just need to know where to look for them.&lt;/p&gt; &lt;p&gt;The following sections walk you through the process of installing an application in OpenShift and then show you how to locate the various Kubernetes resources that support the application within the OpenShift UI. Be advised that the demonstration application uses only the basic Kubernetes resources. Kubernetes ships many other resources out of the box. Moreover, developers can create custom resources. To cover them all with any sort of detail would require a good number of articles. But still, there's a lot of value in understanding how to work with these basic Kubernetes resources. Most if not all applications use them.&lt;/p&gt; &lt;h3&gt;Installing an application from a container image&lt;/h3&gt; &lt;p&gt;You can use the web console in a variety of ways to install an application on OpenShift. One way is to install an application using a container image that's stored in a container image repository such as &lt;a href="https://quay.io/repository/"&gt;Quay.io&lt;/a&gt;. Installing an application from a container image involves declaring the URL to the container image from within the console and then entering some minor configuration settings within the same UI.&lt;/p&gt; &lt;p&gt;Figure 7 shows a portion of the web page in the console where you can install an application from a container image.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/figure-07.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/figure-07.png?itok=07ujcwoX" width="600" height="384" alt="The console UI lets you enter a URL to retrieve an image from an online repository." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 7: The console UI lets you enter a URL to retrieve an image from an online repository.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;After you ask OpenShift to install an application from a container image, OpenShift creates all the Kubernetes resources needed to run the application within the cluster. This includes a Kubernetes &lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/"&gt;deployment&lt;/a&gt; along with its &lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/"&gt;pods&lt;/a&gt;, as well the &lt;a href="https://kubernetes.io/docs/concepts/services-networking/service/"&gt;service&lt;/a&gt; that represents the pods on the Kubernetes network. Also, the installation process creates a &lt;a href="https://docs.openshift.com/container-platform/4.11/rest_api/network_apis/route-route-openshift-io-v1.html"&gt;route&lt;/a&gt; in the form of a DNS name that makes the application accessible on the Internet.&lt;/p&gt; &lt;p&gt;As mentioned many times in these articles, a key feature of the OpenShift web console is that it creates all of an application's resources automatically and exposes them in a graphical manner.&lt;/p&gt; &lt;h3&gt;Viewing the underlying Kubernetes resources&lt;/h3&gt; &lt;p&gt;Figure 8 shows the graphical output that shows up in the web console after OpenShift installs an application. The circular graphic in the illustration represents the application, in this case a web application named &lt;code&gt;simplesite&lt;/code&gt;. The pane on the right side of Figure 8 appears when you click on the center of the circular graphic. Notice that the pane shows the application's Kubernetes pods as well as the service representing the pods on the Kubernetes network. Also, the URL that represents the route to the application on the Internet appears at the bottom of the pane.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/figure-08.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/figure-08.png?itok=2-zkpHEv" width="507" height="272" alt="After installing an application, OpenShift offers interfaces to manage its pods, services, routes, etc." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 8: After installing an application, OpenShift offers interfaces to manage its pods, services, routes, etc.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;You can view the details of a resource by clicking on the link listed in the pane. The details page provides a variety of views for information about a given resource, organized according to the tabs on the horizontal menu bar on the page.&lt;/p&gt; &lt;p&gt;Figure 9 shows the general overview of information relevant to the application's pods, which is presented when you click the &lt;strong&gt;Details&lt;/strong&gt; tab.  In addition, Figure 9 shows the YAML source code implementing the Kubernetes configuration file for the pods. The YAML configuration is created automatically by OpenShift as part of the application installation process. Developers who are familiar with configuration files can tweak the YAML to make changes. The saved changes will cascade into the cluster automatically and the pods will be updated accordingly.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/figure-09.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/figure-09.png?itok=NX1Guxf7" width="600" height="330" alt="You can click on Details to get details about an application, such as its YAML configuration." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 9: You can click on Details to get details about an application, such as its YAML configuration.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Figure 10 shows the information available when you click the &lt;strong&gt;Metrics&lt;/strong&gt; tab in the pod details. You can view metrics about memory usage, CPU utilization, and network I/O, to name just a few examples. The graphical information is available in the web console by default. You don't need to add any additional tools or plugins.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/figure-10.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/figure-10.png?itok=J0VNjPpP" width="600" height="324" alt="The Metrics tab for each pod shows statistics such as memory usage." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 10: The Metrics tab for each pod shows statistics such as memory usage.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;In short, the details for the Kubernetes resources associated with a given application are available within the OpenShift web console. The console presents both general Kubernetes information and information that is specific to each resource. There's a lot of information to view for each Kubernetes resource. Exploring the details page for each resource is a good place to start.&lt;/p&gt; &lt;h2&gt;OpenShift offers a simple interface &lt;/h2&gt; &lt;p&gt;The article covered the knowledge required to understand what OpenShift is and what it does. You learned that OpenShift is an operational layer that sits on top of Kubernetes. All the resources that are available in Kubernetes are also available in OpenShift. You learned that you can interact with OpenShift and the underlying Kubernetes resources using either the &lt;code&gt;oc&lt;/code&gt; CLI or the web console's graphical interface. Also, you learned about using the Administrator and Developer perspectives in the Web Console to work with different OpenShift features as well as the underlying Kubernetes cluster.&lt;/p&gt; &lt;p&gt;Finally, you saw a high-level example of how to install an application into OpenShift from a container image stored on a public registry. In addition, you learned how to use the graphical features available in the OpenShift web console to view detailed information about the Kubernetes resources associated with the application.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/01/11/developers-guide-using-openshift-kubernetes" title="A developer's guide to using OpenShift with Kubernetes"&gt;A developer's guide to using OpenShift with Kubernetes&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Bob Reselman</dc:creator><dc:date>2023-01-11T07:00:00Z</dc:date></entry><entry><title>How to automate devices using the Ansible CIP collection</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/01/10/automate-devices-using-ansible-cip" /><author><name>Josh Swanson</name></author><id>713bfc5a-c5b3-41c2-b277-dbe872388f09</id><updated>2023-01-10T07:00:00Z</updated><published>2023-01-10T07:00:00Z</published><summary type="html">&lt;p&gt;During the past few months, Red Hat has collaborated with &lt;a href="https://www.rockwellautomation.com/en-us.html"&gt;Rockwell Automation&lt;/a&gt; to bring the Red Hat Ansible Automation Platform into a new realm: The control of embedded devices via the &lt;a href="https://www.odva.org/technology-standards/key-technologies/common-industrial-protocol-cip/"&gt;Common Industrial Protocol&lt;/a&gt; (CIP). This article introduces the value and uses of Ansible Automation Platform's &lt;a href="https://galaxy.ansible.com/community/cip"&gt;CIP collection&lt;/a&gt;, now available in Ansible's Galaxy repository. The development site for this collection is on &lt;a href="https://github.com/ansible-collections/community.cip"&gt;GitHub&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Lacking CIP, control over industrial devices has generally been performed by connecting the firmware and programs for a programmable logic controller (PLC) from a laptop over a USB cable. The procedure requires human intervention and isn't particularly scalable.&lt;/p&gt; &lt;p&gt;Our collaboration with Rockwell Automation established the viability of an Ansible Automation Platform project in this space and brought its power to a whole new class of devices.&lt;/p&gt; &lt;h2&gt;Using configuration files to control devices&lt;/h2&gt; &lt;p&gt;At Ansiblefest 2022, we showcased a demo case from Rockwell Automation, using the Ansible Automation Platform to tell the PLC to toggle an LED light and control the speed and direction of a motor via a variable frequency drive. Figure 1 shows how the computing components connect inside the demo case, containing the LED and a round motor.&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig1_27.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig1_27.png?itok=Igko1bTc" width="600" height="338" alt="Computer parts and motors are connected within a case." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 1: Computer parts and motors are connected within a case.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt;Figure 2 shows the execution flow of the architecture. Ansible Automation Platform is the automation controller.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig2_18.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig2_18.png?itok=aYbw_XZQ" width="600" height="272" alt="The execution flow of the architecture." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 2: Ansible Automation Platform controls the PLC, which controls the drive and ultimately the motor.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;The behavior of the motor and LED is automated by adjusting tags (variables) within the PLC program using the new CIP collection. Traditional YAML and natural-language playbooks can make changes against devices. For example, the following code block instructs the PLC to start spinning the motor forward at 1Hz:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-yaml"&gt;- name: Start motor slowly community.cip.ensure_tags: tags: - name: "Start" # Set ‘Start' to true value: True - name: "Stop" # Set ‘Stop' to false value: False - name: "MotorSetPoint" # Set the frequency of the motor value: 100 - name: "isForward" # Set the direction value: True&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Figure 3 shows the illuminated LED, and the motor has rotated a bit.&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig3.jpeg" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig3.jpeg?itok=TwixzSGx" width="600" height="280" alt="The light is illuminated and the motor has rotated." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 3: The light is illuminated and the motor has rotated.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt;After the task runs, the frequency shows on the drive.&lt;/p&gt; &lt;p&gt;Another task can adjust this tag again as follows:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-yaml"&gt;- name: Speed up community.cip.ensure_tags: tags: - name: "MotorSetPoint" value: 5000&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The new tag sets the drive to 50Hz, and the motor spins far more rapidly (Figure 4).&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig4.jpeg" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig4.jpeg?itok=bRQiPkjc" width="600" height="280" alt="The round motor is spinning rapidly." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 4: The round motor is spinning rapidly.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;h2&gt;Real-world use cases for CIP collection&lt;/h2&gt; &lt;p&gt;While adjusting the motor's revolutions per minute (RPMs) and toggling an LED might be a toy application, the CIP collection can manage industrial devices in production environments.&lt;/p&gt; &lt;p&gt;In the future, PLCs (and ultimately, the industrial systems they control) will become far more composable. Industrial device management can exploit some of the best practices from the DevOps world, such as infrastructure as code and GitOps, to enable agility at a scale not achievable today. New firmware versions that address vulnerabilities can be rolled out globally in a matter of minutes without requiring human intervention at every industrial site. Rapid prototyping can enable the development and testing of PLC programs to add features and functionality, which are immediately deployed to existing manufacturing lines. Also, manufacturing lines can be rapidly reconfigured and redeployed to manufacture new products without taking the line down for an extended period to reconfigure the control systems manually.&lt;/p&gt; &lt;h2&gt;The CIP collection development team&lt;/h2&gt; &lt;p&gt;Developing the CIP collection was a major team effort. We welcome your feedback. Comment below if you have questions, or you can get involved by visiting the GitHub repo &lt;a href="https://github.com/ansible-collections/community.cip/issues"&gt;issues page&lt;/a&gt;. We offer special thanks to the following collection authors from Rockwell Automation and Red Hat:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Aaron Neustedter, Rockwell Automation&lt;/li&gt; &lt;li&gt;&lt;span data-rich-links="{"per_n":"Adam Miller","per_e":"admiller@redhat.com","type":"person"}"&gt;Adam Miller&lt;/span&gt;, Red Hat&lt;/li&gt; &lt;li&gt;&lt;span data-rich-links="{"per_n":"Chris Santiago","per_e":"chsantia@redhat.com","type":"person"}"&gt;Chris Santiago&lt;/span&gt;, Red Hat&lt;/li&gt; &lt;li&gt;&lt;span data-rich-links="{"per_n":"Matthew Sandoval","per_e":"msandova@redhat.com","type":"person"}"&gt;Matthew Sandoval&lt;/span&gt;, Red Hat&lt;/li&gt; &lt;li&gt;&lt;span data-rich-links="{"per_n":"Josh Swanson","per_e":"jswanson@redhat.com","type":"person"}"&gt;Josh Swanson&lt;/span&gt;, Red Hat&lt;/li&gt; &lt;li&gt;&lt;span data-rich-links="{"per_n":"Chad Ferman","per_e":"cferman@redhat.com","type":"person"}"&gt;Chad Ferman&lt;/span&gt;, Red Hat&lt;/li&gt; &lt;/ul&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/01/10/automate-devices-using-ansible-cip" title="How to automate devices using the Ansible CIP collection"&gt;How to automate devices using the Ansible CIP collection&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Josh Swanson</dc:creator><dc:date>2023-01-10T07:00:00Z</dc:date></entry><entry><title type="html">Quarkus 2.15.3.Final released - Maintenance release</title><link rel="alternate" href="https://quarkus.io/blog/quarkus-2-15-3-final-released/" /><author><name>Guillaume Smet</name></author><id>https://quarkus.io/blog/quarkus-2-15-3-final-released/</id><updated>2023-01-10T00:00:00Z</updated><content type="html">Today, we released Quarkus 2.15.3.Final, our third maintenance release for Quarkus 2.15. As usual it comes with bugfixes and documentation improvements. It is a recommended upgrade for anyone already using 2.15. If you are not already using 2.15, please refer to our migration guide. Full changelog You can get the...</content><dc:creator>Guillaume Smet</dc:creator></entry><entry><title type="html">How to do a Database dump of H2 DB</title><link rel="alternate" href="http://www.mastertheboss.com/java-ee/jpa/how-to-dump-an-h2-database/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/java-ee/jpa/how-to-dump-an-h2-database/</id><updated>2023-01-09T10:18:34Z</updated><content type="html">Using the H2 Database is a common option when developing application prototypes. Once challenge is that, if you are using it as in-memory embedded H2 database , you cannot access the database from outside the JVM. A simple trick is to create a dump of the database, to check the data in all tables In ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title>How to run the correct Java version after an update</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/01/09/how-run-correct-java-version-after-update" /><author><name>Mohammadi Iram</name></author><id>84eb8107-d7f8-4acd-a14d-882843ddd3e7</id><updated>2023-01-09T07:00:00Z</updated><published>2023-01-09T07:00:00Z</published><summary type="html">&lt;p&gt;When you try to run a &lt;a href="https://developers.redhat.com/topics/enterprise-java"&gt;Java&lt;/a&gt; program after updating your system's version of Java, you are likely to receive an error message such as the following:&lt;/p&gt; &lt;pre&gt; &lt;code&gt;mvn install The JAVA_HOME environment variable is not defined correctly This environment variable is needed to run this program NB: JAVA_HOME should point to a JDK not a JRE &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The source of the problem is probably the setting of your &lt;code&gt;JAVA_HOME&lt;/code&gt; environment variable. This article shows you how to fix this problem.&lt;/p&gt; &lt;h2&gt;The reason for the error message&lt;/h2&gt; &lt;p&gt;Java programs need a Java Runtime Environment (JRE) to run. When you program with Java, the JRE is part of the Java Development Kit (JDK). The meanings of these terms follow:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Java Runtime Environment (JRE): Java source code is compiled and converted to Java bytecode. If you want to run this bytecode on your platform, you need the JRE to load and interpret the bytecode.&lt;/li&gt; &lt;li&gt;Java Development Kit (JDK): This includes a JRE along with a collection of software development tools and libraries to create Java programs that can run on the platform using the JRE.&lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;The importance of JAVA_HOME&lt;/h2&gt; &lt;p&gt;Your shell finds the proper Java environment through an environment variable called &lt;code&gt;JAVA_HOME&lt;/code&gt;. It could point to either a JDK or a JRE. As the error message shown earlier indicates, you should point to your JDK if you have a JDK. When non-developers run Java, they don't need the entire JDK, so they can download a JRE and point &lt;code&gt;JAVA_HOME&lt;/code&gt; to that. You can learn more about the Java platform components in the article, &lt;a href="https://aws.amazon.com/what-is/java-runtime-environment/"&gt;What is the Java Runtime Environment&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;When you upgrade Java, the system installs a new JDK, and you need to update &lt;code&gt;JAVA_HOME&lt;/code&gt; to point to the new location.&lt;/p&gt; &lt;p&gt;Environment variables used in the shell are generally defined in a start-up file. This file is located in your home directory and is called &lt;code&gt;.bashrc&lt;/code&gt; if you use the Bash shell that is the default on Linux. Note the initial dot in the name &lt;code&gt;.bashrc&lt;/code&gt;: this dot means that the file doesn't normally turn up when you display the contents of the directory.&lt;/p&gt; &lt;p&gt;The &lt;code&gt;.bashrc&lt;/code&gt; file is a script that runs when a user logs in. The file itself contains a series of commands to configure the terminal session.&lt;/p&gt; &lt;p&gt;Check your &lt;code&gt;.bashrc&lt;/code&gt; file to see whether it defines &lt;code&gt;JAVA_HOME&lt;/code&gt; and what value is assigned to the environment variable. For instance, you can execute this command in the terminal:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ more ~/.bashrc&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The line defining &lt;code&gt;JAVA_HOME&lt;/code&gt; in the output is as follows:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-17.0.4.1.1–1.fc35.x86_64&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You have to make sure that &lt;code&gt;JAVA_HOME&lt;/code&gt; is set correctly, with version details.&lt;/p&gt; &lt;h2&gt;Choosing a JDK&lt;/h2&gt; &lt;p&gt;In the terminal on a Linux system, run the following command:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ sudo alternatives --config java&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The output displays the versions of Java currently on the system, as shown in Figure 1. The command also issues a prompt allowing you to choose a version.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig2_22.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig2_22.png?itok=fzdFqHjG" width="600" height="141" alt="Choose the JDK you want." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 1: You can choose which JDK you want.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;The version you choose (3 in the figure) contains, within parentheses, a full pathname that you have to assign to your &lt;code&gt;JAVA_HOME&lt;/code&gt; environment variable in your &lt;code&gt;.bashrc&lt;/code&gt; file. After entering the number that you want to use, press the Enter key to finish the command.&lt;/p&gt; &lt;h2&gt;Updating .bashrc&lt;/h2&gt; &lt;p&gt;The next step is to check the value of &lt;code&gt;JAVA_HOME&lt;/code&gt; (or add it, if it is not already present) in the &lt;code&gt;.bashrc&lt;/code&gt; file. If &lt;code&gt;.bashrc&lt;/code&gt; doesn't match the pathname you choose, you can copy the pathname from the terminal display and paste it into &lt;code&gt;.bashrc&lt;/code&gt; as I'll show shortly.&lt;/p&gt; &lt;p&gt;Figure 2 highlights the JDK path I selected in Figure 1.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig3_0.jpeg" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig3_0.jpeg?itok=JV3p49CH" width="600" height="144" alt="Shows the JDK selected: openjdk-17.0.5.0.8–2.fc35.x86_64." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 2: The white highlight shows the JDK we have selected on our system, openjdk-17.0.5.0.8–2.fc35.x86_64.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt; &lt;/p&gt; &lt;p&gt;Figure 3 highlights the JDK path in the &lt;code&gt;JAVA_HOME&lt;/code&gt; setting in my current &lt;code&gt;.bashrc&lt;/code&gt; file.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig4_0.jpeg" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig4_0.jpeg?itok=7i6ywZZM" width="600" height="164" alt="Shows an old JDK: openjdk-17.0.4.1.1–1.fc35.x86_64." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 3: The .bashrc file expects an old JDK, openjdk-17.0.4.1.1–1.fc35.x86_64.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;The paths are different, so I need to update the environment variable in the &lt;code&gt;.bashrc&lt;/code&gt; file to match the path offered by the system. Specifically, I need to change the JDK version in the path from &lt;code&gt;openjdk-17.0.4.1.1–1.fc35.x86_64&lt;/code&gt; to &lt;code&gt;openjdk-17.0.5.0.8–2.fc35.x86_64&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;When you save your changes, &lt;code&gt;.bashrc&lt;/code&gt; looks like Figure 4.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig5_10.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig5_10.png?itok=ogrfm7cT" width="599" height="240" alt="Shows the updated .bashrc file." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 4: The .bashrc file is updated now to expect openjdk-17.0.5.0.8–2.fc35.x86_64.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;Updating the shell&lt;/h2&gt; &lt;p&gt;To reflect the changes in your shell, either close and launch the terminal again or use the following command:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ source ~/.bashrc&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In this way, you can easily update your &lt;code&gt;JAVA_HOME&lt;/code&gt; environment variable and continue coding in Java.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/01/09/how-run-correct-java-version-after-update" title="How to run the correct Java version after an update"&gt;How to run the correct Java version after an update&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Mohammadi Iram</dc:creator><dc:date>2023-01-09T07:00:00Z</dc:date></entry><entry><title type="html">How to solve the error java.net.SocketException: Connection reset</title><link rel="alternate" href="http://www.mastertheboss.com/java/how-to-solve-the-error-java-net-socketexception-connection-reset/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/java/how-to-solve-the-error-java-net-socketexception-connection-reset/</id><updated>2023-01-06T09:06:57Z</updated><content type="html">A SocketException Connection reset is one of the most common Runtime errors you can find in Java applications. As the name implies, it happens during a network connection which terminates abruptly. In this tutorial we will teach you which is the best action plan to find the root cause of the issue. What is a ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry></feed>
